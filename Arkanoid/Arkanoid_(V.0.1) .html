<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Aranoid - Smooth Paddle</title>
  <style>
    canvas {
      background: #111122;
      display: block;
      margin: auto;
      border: 2px solid #ccc;
    }
    body {
      text-align: center;
      background-color: black;
      color: white;
      font-family: Courier, monospace;
    }
  </style>
</head>
<body>
  <h1>Aranoid - Smooth Paddle</h1>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let paddle = { x: 350, y: 550, width: 100, height: 10, speed: 8 };
    let ball = { x: 400, y: 300, dx: 4, dy: -4, radius: 10 };
    let bricks = [];
    let score = 0;
    let gameRunning = true;

    let keys = { left: false, right: false };

    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 10; c++) {
        bricks.push({ x: 70 * c + 15, y: 50 * r + 30, width: 60, height: 20, hit: false });
      }
    }

    function drawPaddle() {
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = "white";
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      for (let brick of bricks) {
        if (!brick.hit) {
          ctx.fillStyle = "#8888ff";
          ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
        }
      }
    }

    function drawScore() {
      ctx.fillStyle = "white";
      ctx.font = "20px Courier";
      ctx.fillText(`Score: ${score}`, 650, 25);
    }

    function drawMessage(msg) {
      ctx.fillStyle = "yellow";
      ctx.font = "28px Courier";
      ctx.fillText(msg, 150, 300);
    }

    function updatePaddle() {
      if (keys.left && paddle.x > 0) paddle.x -= paddle.speed;
      if (keys.right && paddle.x + paddle.width < canvas.width) paddle.x += paddle.speed;
    }

    function updateBall() {
      const steps = 2;
      for (let i = 0; i < steps; i++) {
        ball.x += ball.dx / steps;
        ball.y += ball.dy / steps;

        // Wall collision
        if (ball.x < ball.radius) {
          ball.x = ball.radius;
          ball.dx *= -1;
        }
        if (ball.x > canvas.width - ball.radius) {
          ball.x = canvas.width - ball.radius;
          ball.dx *= -1;
        }
        if (ball.y < ball.radius) {
          ball.y = ball.radius;
          ball.dy *= -1;
        }

        // Paddle collision
        if (
          ball.y + ball.radius >= paddle.y &&
          ball.x >= paddle.x &&
          ball.x <= paddle.x + paddle.width &&
          ball.dy > 0
        ) {
          let relativeHitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
          relativeHitPos = Math.max(Math.min(relativeHitPos, 0.9), -0.9);
          let angle = relativeHitPos * (Math.PI / 3); // Â±60 degrees
          let speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
          ball.dx = speed * Math.sin(angle);
          ball.dy = -Math.abs(speed * Math.cos(angle));
          ball.y = paddle.y - ball.radius - 1;
        }

        // Brick collision
        for (let brick of bricks) {
          if (!brick.hit &&
            ball.x + ball.radius > brick.x &&
            ball.x - ball.radius < brick.x + brick.width &&
            ball.y + ball.radius > brick.y &&
            ball.y - ball.radius < brick.y + brick.height
          ) {
            brick.hit = true;
            score += 10;

            // Reverse direction based on penetration depth
            let overlapX = Math.min(
              ball.x + ball.radius - brick.x,
              brick.x + brick.width - (ball.x - ball.radius)
            );
            let overlapY = Math.min(
              ball.y + ball.radius - brick.y,
              brick.y + brick.height - (ball.y - ball.radius)
            );

            if (overlapX < overlapY) {
              ball.dx *= -1;
            } else {
              ball.dy *= -1;
            }

            break;
          }
        }
      }

      // Win condition
      if (bricks.every(b => b.hit)) {
        gameRunning = false;
      }

      // Missed ball
      if (ball.y > canvas.height) {
        gameRunning = false;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawPaddle();
      drawBall();
      drawBricks();
      drawScore();

      if (!gameRunning) {
        if (bricks.every(b => b.hit)) {
          drawMessage("You Win, you champion ! Press R to play again !");
        } else {
          drawMessage("Game Over! Press R to Restart");
        }
        return;
      }

      updatePaddle();
      updateBall();

      requestAnimationFrame(draw);
    }

    document.addEventListener("keydown", e => {
      if (e.key === "ArrowLeft") keys.left = true;
      if (e.key === "ArrowRight") keys.right = true;
      if (e.key === "r" || e.key === "R") location.reload();
    });

    document.addEventListener("keyup", e => {
      if (e.key === "ArrowLeft") keys.left = false;
      if (e.key === "ArrowRight") keys.right = false;
    });

    draw();
  </script>
</body>
</html>
