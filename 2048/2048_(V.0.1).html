<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>2048 with Canvas</title>
  <style>
    body {
      background-color: #bbada0;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      margin: 0;
    }
    canvas {
      margin-top: 30px;
      background-color: #bbada0;
    }
    h1 {
      color: white;
    }
    #score {
      font-size: 20px;
      color: white;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <h1>2048</h1>
  <div id="score">Score: 0</div>
  <canvas id="gameCanvas" width="400" height="400"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const GRID_SIZE = 4;
    const TILE_SIZE = 100;
    let grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
    let score = 0;
    const START_TILES = 2;

    const COLORS = {
      0: "#cdc1b4", 2: "#eee4da", 4: "#ede0c8", 8: "#f2b179",
      16: "#f59563", 32: "#f67c5f", 64: "#f65e3b", 128: "#edcf72",
      256: "#edcc61", 512: "#edc850", 1024: "#edc53f", 2048: "#edc22e"
    };

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          drawTile(x, y, grid[y][x]);
        }
      }
      document.getElementById('score').textContent = `Score: ${score}`;
    }

    function drawTile(x, y, value) {
      const px = x * TILE_SIZE;
      const py = y * TILE_SIZE;
      ctx.fillStyle = COLORS[value] || "#3c3a32";
      ctx.fillRect(px + 5, py + 5, TILE_SIZE - 10, TILE_SIZE - 10);

      if (value !== 0) {
        ctx.fillStyle = value <= 8 ? "black" : "white";
        ctx.font = value < 128 ? "32px Arial" : "28px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(value, px + TILE_SIZE / 2, py + TILE_SIZE / 2);
      }
    }

    function compress(row) {
      const newRow = row.filter(v => v !== 0);
      while (newRow.length < GRID_SIZE) newRow.push(0);
      return newRow;
    }

    function merge(row) {
      for (let i = 0; i < GRID_SIZE - 1; i++) {
        if (row[i] !== 0 && row[i] === row[i + 1]) {
          row[i] *= 2;
          score += row[i];
          row[i + 1] = 0;
        }
      }
      return row;
    }

    function moveLeft() {
      let moved = false;
      for (let i = 0; i < GRID_SIZE; i++) {
        const original = [...grid[i]];
        let row = compress(grid[i]);
        row = merge(row);
        row = compress(row);
        grid[i] = row;
        if (original.toString() !== row.toString()) moved = true;
      }
      if (moved) {
        addRandomTile();
        drawGrid();
        checkGameOver();
      }
    }

    function moveRight() {
      let moved = false;
      for (let i = 0; i < GRID_SIZE; i++) {
        const original = [...grid[i]];
        let row = compress(grid[i].slice().reverse());
        row = merge(row);
        row = compress(row);
        grid[i] = row.reverse();
        if (original.toString() !== grid[i].toString()) moved = true;
      }
      if (moved) {
        addRandomTile();
        drawGrid();
        checkGameOver();
      }
    }

    function moveUp() {
      let moved = false;
      for (let col = 0; col < GRID_SIZE; col++) {
        let column = grid.map(row => row[col]);
        const original = [...column];
        column = compress(column);
        column = merge(column);
        column = compress(column);
        column.forEach((val, row) => grid[row][col] = val);
        if (original.toString() !== column.toString()) moved = true;
      }
      if (moved) {
        addRandomTile();
        drawGrid();
        checkGameOver();
      }
    }

    function moveDown() {
      let moved = false;
      for (let col = 0; col < GRID_SIZE; col++) {
        let column = grid.map(row => row[col]).reverse();
        const original = [...column];
        column = compress(column);
        column = merge(column);
        column = compress(column);
        column.reverse().forEach((val, row) => grid[row][col] = val);
        if (original.reverse().toString() !== grid.map(r => r[col]).toString()) moved = true;
      }
      if (moved) {
        addRandomTile();
        drawGrid();
        checkGameOver();
      }
    }

    function addRandomTile() {
      const empty = [];
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] === 0) empty.push([y, x]);
        }
      }
      if (empty.length > 0) {
        const [y, x] = empty[Math.floor(Math.random() * empty.length)];
        grid[y][x] = Math.random() < 0.9 ? 2 : 4;
      }
    }

    function checkGameOver() {
  for (let row of grid) {
    if (row.includes(0)) return;
  }
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE - 1; x++) {
      if (grid[y][x] === grid[y][x + 1]) return;
    }
  }
  for (let x = 0; x < GRID_SIZE; x++) {
    for (let y = 0; y < GRID_SIZE - 1; y++) {
      if (grid[y][x] === grid[y + 1][x]) return;
    }
  }

  // Draw Game Over overlay
  ctx.fillStyle = "rgba(238, 228, 218, 0.73)";
  ctx.fillRect(0, canvas.height / 2 - 40, canvas.width, 80);

  ctx.fillStyle = "#776e65";
  ctx.font = "30px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("Game Over!", canvas.width / 2, canvas.height / 2);

  return true;
}

    function restartGame() {
      grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
      score = 0;
      for (let i = 0; i < START_TILES; i++) addRandomTile();
      drawGrid();
    }

    // Event listeners
    window.addEventListener("keydown", e => {
      switch (e.key) {
        case "ArrowLeft": moveLeft(); break;
        case "ArrowRight": moveRight(); break;
        case "ArrowUp": moveUp(); break;
        case "ArrowDown": moveDown(); break;
        case "Enter": restartGame(); break;
      }
    });

    // Start game
    restartGame();
  </script>
</body>
</html>
